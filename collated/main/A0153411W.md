# A0153411W
###### /java/seedu/task/commons/core/Config.java
``` java
	private static Config instance = null;
```
###### /java/seedu/task/commons/core/Config.java
``` java
	private HashMap<String, String> customCommands = new HashMap<String, String>();

```
###### /java/seedu/task/commons/core/Config.java
``` java
	public static Config getInstance() {
		if (instance == null) {
			instance = new Config();
		}
		return instance;
	}

	public static void setInstance(Config instance) {
		Config.instance = instance;
	}

```
###### /java/seedu/task/commons/core/Config.java
``` java
	public void setCustomCommandFormat(String commandWord, String userCommand)
			throws DublicatedValueCustomCommandsException {
		for (String key : customCommands.keySet()) {
			if (customCommands.get(key)!= null && customCommands.get(key).equals(userCommand) && !key.equals(commandWord))
				throw new DublicatedValueCustomCommandsException("This custom command already exists for:" + key);
		}
		customCommands.put(commandWord, userCommand);
	}

	public String getCommandbyCustomValue(String userCommand) {
		for (String key : customCommands.keySet()) {
			if (customCommands.get(key).equals(userCommand))
				return key;
		}
		return "";
	}
	
	public String getCustomValuebyCommand(String command) {
		return customCommands.get(command);
	}
```
###### /java/seedu/task/commons/core/Config.java
``` java
	@SuppressWarnings("serial")
	public class DublicatedValueCustomCommandsException extends Exception {
		public DublicatedValueCustomCommandsException(String message) {
			super(message);
		}
	}
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java

```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
	/**
	 * Execute undo method for add command - Delete added tasks to restore 
	 * task manager to state before method was executed
	 * @throws TaskNotFoundException
	 * 				if task to delete was not found
	 */
	@Override
	public CommandResult executeUndo() {
		try {
			for (Task task : tasksToAdd) {
				model.deleteTask(task);
			}
		} catch (TaskNotFoundException e) {
			return new CommandResult(MESSAGE_NOT_FOUND);
		}
		return new CommandResult(MESSAGE_SUCCESS_UNDO);
	}

	@Override
	public boolean isReversible() {
		return true;
	}
}
```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
	public static final String MESSAGE_SUCCESS_UNDO = "Undo of clear command";
	private ArrayList<Task> savedTasksForUndo;
```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
		saveModelForUndo();
```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
	/**
	 * Before clear command is executed, save all tasks
	 * for undo command.
	 */
	private void saveModelForUndo() {
		savedTasksForUndo = new ArrayList<Task>();
		for (ReadOnlyTask task : model.getFilteredTaskList()) {
```
###### /java/seedu/task/logic/commands/CustomizeCommand.java
``` java
public class CustomizeCommand extends Command {

	public static final String COMMAND_WORD = "customize";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Add customized format for specified command"
			+ " Parameters: command_format" + " Example: " + COMMAND_WORD + " LIST f/ls";

	private String commandWord;
	private String userCommand;
	private String userCommandForUndo; 

	public CustomizeCommand(String commandWord, String userCommand) {
		this.commandWord = commandWord.toLowerCase();
		this.userCommand = userCommand.toLowerCase();
	}

	@Override
	public CommandResult execute() {
		Config config = Config.getInstance();
		String configFilePathUsed = Config.DEFAULT_CONFIG_FILE;
		if (!isCommandWordPresent(commandWord))
			return new CommandResult("Command:" + commandWord + " is not found.");
		try {
			//prepareCommandForUndo(config);
			config.setCustomCommandFormat(commandWord, userCommand);
			ConfigUtil.saveConfig(config, configFilePathUsed);
			new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
			return new CommandResult("Add customized format: " + userCommand + " for command: " + commandWord);
		} catch (IOException e) {
			// remove this command from list for undo
			model.getCommandForUndo();
			return new CommandResult(
					"Failed to add customized format: " + userCommand + " for command: " + commandWord);
		} catch (DublicatedValueCustomCommandsException e) {
			model.getCommandForUndo();
			return new CommandResult(
					"Failed to add customized format: " + userCommand + " for command: " + commandWord);
		}
	}

	private void prepareCommandForUndo(Config config){
		userCommandForUndo = config.getCustomValuebyCommand(commandWord);
	}
	
	private boolean isCommandWordPresent(String commandWord) {
		List<String> commands = Command.getAllCommands();
		return commands.contains(commandWord);
	}

	/**
	 * Save Command is not reversible.
	 */
	@Override
	public CommandResult executeUndo() {
		if(userCommandForUndo == null)
			return new CommandResult("Method cannot be undone because command: "+commandWord+" didn't have set previous custom command format");
		this.userCommand = userCommandForUndo;
		return this.execute();
	}

	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
    public final int targetIndex;
    private Task savedTaskForUndo;
```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
        saveTaskForUndo(taskToDelete);
```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
    /**
     * Save task for undo command before it is deleted.
     */
	private void saveTaskForUndo(ReadOnlyTask task){
```
###### /java/seedu/task/logic/commands/DoneCommand.java
``` java
	/**
	 * Execute undo method for done command - Delete task with done status
	 * and add again with ongoing status to restore 
	 * task manager to state before method was executed.
	 * Assume that done task is at the end of list.
	 * If task was completed before done command, method is finished.
	 * @throws DuplicateTaskException
	 * 				if task to add is already in manager
	 * @throws TaskNotFoundException
	 * 				if task was not found
	 */
	@Override
	public CommandResult executeUndo() {
		if(targetStatus.equals("COMPLETED"))
			return new CommandResult(String.format(MESSAGE_SUCCESS_UNDO));
		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
		int numberOfTasks = lastShownList.size();
		ReadOnlyTask task = lastShownList.get(numberOfTasks - 1);
```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
			saveTaskForUndo(selectedTask);
```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
	/**
	 * Save task which is edited to restore it for undo command
	 */
	private void saveTaskForUndo(ReadOnlyTask task){
```
###### /java/seedu/task/logic/commands/ExitCommand.java
``` java
	/**
	 * Command for exit is not reversible.
	 */
	@Override
	public CommandResult executeUndo() {
        return null;
	}


	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/FindCommand.java
``` java
	@Override
	public CommandResult executeUndo() {
        return null;
	}


	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/HelpCommand.java
``` java
	@Override
	public CommandResult executeUndo() {
		return null;
	}


	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/IncorrectCommand.java
``` java
	/**
	 * Incorrect command is not reversible.
	 */
	@Override
	public CommandResult executeUndo() {
		return null;
	}


	@Override
	public boolean isReversible() {
		return false;
	}

}

```
###### /java/seedu/task/logic/commands/ListCommand.java
``` java
	@Override
	public CommandResult executeUndo() {
		return null;
	}


	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/SaveCommand.java
``` java
	/**
	 * Save Command is not reversible.
	 */
	@Override
	public CommandResult executeUndo() {
		return null;
	}


	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
	/**
	 * Select Command is not reversible.
	 */
	@Override
	public CommandResult executeUndo() {
		return null;
	}

	@Override
	public boolean isReversible() {
		return false;
	}

}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
	/**
	 * Undo Command is not reversible.
	 */
	@Override
	public CommandResult executeUndo() {
		return null;
	}

	@Override
	public boolean isReversible() {
		return false;
	}
}
```
###### /java/seedu/task/logic/LogicManager.java
``` java
        addCommandForUndo(command);
```
###### /java/seedu/task/logic/LogicManager.java
``` java
    //Add command (if reversible) to UndoManager
    private void addCommandForUndo(Command command){
    	if(command.isReversible()){
    		model.updateCommandsForUndo(command);
    	}
    }
}
```
###### /java/seedu/task/logic/parser/Parser.java
``` java

```
###### /java/seedu/task/logic/parser/Parser.java
``` java
	private String getCommandWord(Matcher matcher) {
		String command = matcher.group("commandWord");
		if (Command.getAllCommands().contains(command))
			return command;
		else {
			command = Config.getInstance().getCommandbyCustomValue(command);
			return command;
		}
	}
    
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     * @throws ParseException 
     */

    private Command prepareAdd(String args) throws ParseException{
```
###### /java/seedu/task/logic/parser/Parser.java
``` java

```
###### /java/seedu/task/logic/parser/Parser.java
``` java
			return new AddCommand(argsTokenizer.getPreamble(), 
					isInputPresent(argsTokenizer.getValue(descriptionPrefix)),
					isInputPresent(argsTokenizer.getValue(startDatePrefix)),
					isInputPresent(argsTokenizer.getValue(dueDatePrefix)),
					isInputPresent(argsTokenizer.getValue(intervalPrefix)),
					isInputPresent(argsTokenizer.getValue(timeIntervalPrefix)),
					argsTokenizer.getValue(taskColorPrefix),
					toSet(argsTokenizer.getAllValues(tagArgumentsPrefix)));
```
###### /java/seedu/task/logic/parser/Parser.java
``` java
	private Command prepareCustomize(String args) throws ParseException {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(formatCustomCommandPrefix);
		argsTokenizer.tokenize(args);
		try {
			return new CustomizeCommand(argsTokenizer.getPreamble(), argsTokenizer.getValue(formatCustomCommandPrefix));
		} catch (NoSuchElementException nsee) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CustomizeCommand.MESSAGE_USAGE));
		} catch (NoValueForRequiredTagException nvfrt) {
			return new IncorrectCommand(nvfrt.getMessage());
		}
	}
```
###### /java/seedu/task/model/Model.java
``` java
    /** Updates Commands For Undo Stack with new executed command*/
    void updateCommandsForUndo(Command commandForUndo);
    
    /** Get Command for undo*/
    Command getCommandForUndo(); 
}
```
###### /java/seedu/task/model/ModelManager.java
``` java
    private final UndoCommandManager undoManager;
```
###### /java/seedu/task/model/ModelManager.java
``` java
        undoManager = new UndoCommandManager();
```
###### /java/seedu/task/model/ModelManager.java
``` java
        undoManager = new UndoCommandManager();
```
###### /java/seedu/task/model/ModelManager.java
``` java
    @Override
    public synchronized void addTaskWithSpecifiedIndex(Task task, int index) throws UniqueTaskList.DuplicateTaskException {
    	taskManager.addAtSpecificPlace(task, index);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }
```
###### /java/seedu/task/model/task/Interval.java
``` java
/**
 * Represents a Task's interval in the address book.
 */
public class Interval {

    public static final String MESSAGE_INTERVAL_CONSTRAINTS =
            "Interval should only contain numbers";
    public static final String INTERVAL_VALIDATION_REGEX = "[1-9][0-9]*|1";
    public static final Integer DEFAULT_VALUE= 1;
    public final Integer value;
    

    /**
     * Validates given interval.
     *
     * @throws IllegalValueException if given interval string is invalid.
     */
	public Interval(String interval) throws IllegalValueException {
		assert interval != null;
		if (interval.equals("Not Set")) {
			this.value = DEFAULT_VALUE;
		} else {
			interval = interval.trim();
			if (!isValidInterval(interval)) {
				throw new IllegalValueException(MESSAGE_INTERVAL_CONSTRAINTS);
			}
			this.value = Integer.parseInt(interval.trim());
		}
	}

    /**
     * Returns if a given string is a valid task interval.
     */
    public static boolean isValidInterval(String test) {
        return test.matches(INTERVAL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Interval // instanceof handles nulls
                && this.value.equals(((Interval) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/task/model/task/Status.java
``` java
public class Status {

    public String status;
    
    public Status(String status) {
        this.status = status;
    }
    
    @Override
    public String toString() {
        return status;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                && this.status.equals(((Status) other).status)); // state check
    }

    @Override
    public int hashCode() {
        return status.hashCode();
    }
}
```
###### /java/seedu/task/model/task/Task.java
``` java

```
###### /java/seedu/task/model/task/TimeInterval.java
``` java
/**
 * Represents a Task's time interval in the address book.
 */
public class TimeInterval {

    public static final String MESSAGE_TIME_INTERVAL_CONSTRAINTS =
            "Time interval should only contain numbers";
    public static final String TIME_INTERVAL_VALIDATION_REGEX = "[1-9][0-9]*|1";
    public static final Integer DEFAULT_VALUE= 7;
    
    public Integer value;


    /**
     * Validates given interval.
     *
     * @throws IllegalValueException if given interval string is invalid.
     */
	public TimeInterval(String timeInterval) throws IllegalValueException {
		assert timeInterval != null;
		if (timeInterval.equals("Not Set")) {
			this.value = DEFAULT_VALUE;
		} else {
			timeInterval = timeInterval.trim();
			if (!isValidTimeInterval(timeInterval)) {
				throw new IllegalValueException(MESSAGE_TIME_INTERVAL_CONSTRAINTS);
			}
			this.value = Integer.parseInt(timeInterval.trim());
		}
	}

    /**
     * Returns if a given string is a valid task time interval.
     */
    public static boolean isValidTimeInterval(String test) {
        return test.matches(TIME_INTERVAL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TimeInterval // instanceof handles nulls
                && this.value.equals(((TimeInterval) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/task/model/task/Title.java
``` java
public class Title {

    public static final String MESSAGE_TITLE_CONSTRAINTS = "Task titles should be spaces or alphanumeric characters";
    public static final String TITLE_VALIDATION_REGEX = "[\\p{Alnum} ]+";

    public final String fullTitle;

    /**
     * Validates given title.
     *
     * @throws IllegalValueException if given title string is invalid.
     */
    public Title(String title) throws IllegalValueException {
        assert title != null;
        title = title.trim();
        if (!isValidTitle(title)) {
            throw new IllegalValueException(MESSAGE_TITLE_CONSTRAINTS);
        }
        this.fullTitle = title;
    }

    /**
     * Returns true if a given string is a valid task title.
     */
    public static boolean isValidTitle(String test) {
        return test.matches(TITLE_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return fullTitle;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Title // instanceof handles nulls
                && this.fullTitle.equals(((Title) other).fullTitle)); // state check
    }

    @Override
    public int hashCode() {
        return fullTitle.hashCode();
    }

}
```
###### /java/seedu/task/model/task/UniqueTaskList.java
``` java
    /**	
     * Adds a task to the list at specific place
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void addAtSpecificPlace(Task toAdd, int index) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(index,toAdd);
    }
```
###### /java/seedu/task/model/TaskManager.java
``` java
    /**
     * Adds a task to the task manager at specific place.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addAtSpecificPlace(Task p, int index) throws UniqueTaskList.DuplicateTaskException {
        syncTagsWithMasterList(p);
        tasks.addAtSpecificPlace(p, index);
    }
```
###### /java/seedu/task/model/UndoCommandManager.java
``` java
/**
 * Manager for undo command
 */
public class UndoCommandManager {
	
	private final Stack<Command> executedCommands;
	
	public UndoCommandManager(){
		executedCommands= new Stack<Command>();
	}
	
	public void addCommand(Command command){
		executedCommands.push(command);
	}
	
	public Command getCommandForUndo() throws EmptyStackException{
		return executedCommands.pop();
	}
}
 




```
